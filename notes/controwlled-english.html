<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Controwlled English | Victor Charpenay</title>
    <link rel="stylesheet" href="../css/basic.css">
    <script src="../js/n3.min.js"></script>

    <style>
        #panels {
            text-align: center;
        }

        #panels textarea {
            resize: vertical;
        }

        #panels input {
            margin-top: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <h1>Contr<span style="color: steelblue;">owl</span>led English</h1>

    <p class="info">
        October 2025
    </p>

    <p>
        Controwlled English is a controlled language that provides a full-text representation of RDF triples. It was inspired by <a href="https://github.com/LogicalContracts/LogicalEnglish">Logical English</a> and <a href="https://attempto.ifi.uzh.ch/">Attempot Controlled English (ACE)</a>.
    </p>
    <p>
        Controwlled English (or any other "controwlled" language) is based on annotations on RDF classes and properties, similar to <code>rdfs:label</code> statements. Unlabelled blank nodes are handled via relative clauses, such that no variable is required to verbalize triples. As a consequence, unlabelled blank nodes must be tree-shaped, as would be the model of an existential ontology (EL++ and its fragments).
    </p>
    <p>
        Translate Turtle into Controwlled English:
    </p>

    <div id="panels">
        <textarea id="ttl-input" rows="10" cols="80"></textarea>
        <input id="translate-btn" type="button" value="Translate">
        <textarea id="cowl-output" readonly rows="10" cols="80"></textarea>
        <input id="copy-btn" type="button" value="Copy to clipboard">
    </div>

<!-- @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix cowl: <http://purl.org/controwlled#> .
@prefix ex: <http://example.org/> .

ex:C cowl:template "something"@en .
ex:p cowl:template "knows <>"@en .
ex:q cowl:template "has <> as property"@en .

ex:s rdfs:label "Alice" .
ex:o rdfs:label "Bob" .
ex:t rdfs:label "Cassie" .

ex:s
  a ex:C ;
  ex:p ex:o ;
  ex:q ex:o ;
  ex:p "Robert" ;
  ex:q [ ex:p "X" ; ex:q ex:t ] . -->

    <script type="text/javascript">
        const type = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
        const label = "http://www.w3.org/2000/01/rdf-schema#label";
        const template = "http://purl.org/controwlled#template";

        function serialize(quad) {
            let s = quad.subject;
            let p = quad.predicate;
            let o = quad.object;

            return s.value + " " + p.value + " " + o.value;
        }

        function Translator(quads) {
            this.templates = {};
            this.index = {};
            this.roots = [];

            for (quad of quads) {
                let s = quad.subject;
                let p = quad.predicate;
                let o = quad.object;

                if (p.value === template) {
                    // TODO check template parameters
                    // TODO check language tag and prefer English
                    this.templates[s.value] = o;
                } else {
                    let item = this.getItem(s);

                    if (p.value === label) {
                        // TODO check language tag and prefer English
                        item.label = o;
                    } else if (p.value === type) {
                        if (!item.types) item.types = [];
                        item.types.push(o);
                    } else {
                        if (!item.predicates) {
                            item.predicates = {};

                            let isRoot =
                                s.termType === "NamedNode"
                                || (s.termType === "BlankNode"
                                    && this.roots.length === 0);

                            // TODO blank node might not be root after all

                            if (isRoot) this.roots.push(item);
                        }

                        if (!item.predicates[p.value]) {
                            item.predicates[p.value] = [];
                        }

                        item.predicates[p.value].push(o);
                    }
                }
            }
        };

        Translator.prototype.getItem = function(node) {
            let id = node.value;
            let item = this.index[id];

            if (!item) {
                item = { node: node };
                this.index[id] = item;
            }
            
            return item;
        };

        Translator.prototype.getConjunction = function(phrases) {
            let n = phrases.length - 1;
            
            if (n > 0) phrases[n] = "and " + phrases[n];
            return phrases.join(", ");
        };

        Translator.prototype.getNodePhrase = function(node) {
            let item = this.getItem(node);

            // literals are their own label
            if (node.termType === "Literal") item = { label: node };
            
            if (item.label) return item.label.value;

            let np = item.types ?
                this.getClassPhrase(item.types) :
                "a thing"; // owl:Thing

            if (item.predicates) {
                let pps = this.getPropertyPhrases(item.predicates);
                np += " that " + pps;
            }

            return np || undefined;
        };

        Translator.prototype.getClassPhrase = function(classes) {
            let nps = classes
            .map(c => {
                let tpl = this.templates[c.value];

                if (tpl) return tpl.value;
                else console.warn("Ignoring type: ", c.value);
            })
            .filter(np => np);

            return this.getConjunction(nps);
        }

        Translator.prototype.getPropertyPhrase = function(id, nodes) {
            let tpl = this.templates[id];

            if (tpl) {
                let nps = nodes
                .map(node => this.getNodePhrase(node))
                .filter(np => np);

                return tpl.value.replace("<>", this.getConjunction(nps));
            } else console.warn("Ignoring predicate: ", id);
        };

        Translator.prototype.getPropertyPhrases = function(predicates) {
            let pps = [];

            for (id in predicates) {
                let nodes = predicates[id];
                pps.push(this.getPropertyPhrase(id, nodes));
            }

            return this.getConjunction(pps);
        }

        Translator.prototype.getSentence = function(node) {
            let item = this.getItem(node);

            if (!item.types && !item.predicate) return undefined;

            let np = this.getNodePhrase(node);

            let sentences = [];

            if (item.types) {
                let cp = this.getClassPhrase(item.types);
                sentences.push(np + " is " + cp + ".");
            }

            if (item.predicates) {
                let pps = this.getPropertyPhrases(item.predicates);
                sentences.push(np + " " + pps + ".");
            }

            return sentences.join(" ");
        }

        Translator.prototype.getAnaphoricSentence = function(node) {
            // TODO have indication of which anaphor to use (it/they/...)
        };

        Translator.prototype.getSentences = function() {
            let sentences = this.roots.map(item => this.getSentence(item.node));
            return sentences.join("\n");
        };
    </script>

    <script type="text/javascript">
        const parser = new N3.Parser();

        function parse(ttl) {
            let quads = [];

            return new Promise((resolve, reject) => {
                parser.parse(ttl, (error, quad, prefixes) => {
                    if (error) reject(error);
                    else if (quad) quads.push(quad);
                    else resolve(quads);
                });
            })
        }

        async function translate(ttl) {
            let quads = await parse(ttl);
            let translator = new Translator(quads);
            return translator.getSentences();
        }
    </script>

    <script>
        const ttlInput = document.getElementById('ttl-input');
        const translateButton = document.getElementById('translate-btn');
        const cowlOutput = document.getElementById('cowl-output');
        const copyButton = document.getElementById('copy-btn');

        translateButton.onclick = () => {
            let ttl = ttlInput.value;
            
            translate(ttl)
            .then(txt => cowlOutput.value = txt)
            .catch(error => console.error(error));
        };

        copyButton.onclick = () => {
            navigator.clipboard.writeText(cowlOutput.value);
        };
    </script>
<body>

</html>