<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Controwlled English | Victor Charpenay</title>
    <link rel="stylesheet" href="../css/basic.css">
    <script src="../js/n3.min.js"></script>

    <style>
        #panels {
            text-align: center;
        }

        #panels textarea {
            resize: vertical;
        }

        #panels input {
            margin-top: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <h1>Contr<span style="color: steelblue;">owl</span>led English</h1>

    <p class="info">
        October 2025
    </p>

    <p>
        Language models, as a by-product, capture interdependencies between triples. To do so, however, they need a full-text representation of triples. Controwlled English is a controlled language created for that purpose. It was inspired by <a href="https://github.com/LogicalContracts/LogicalEnglish">Logical English</a>.
    </p>
    <p>
        Translate Turtle into Controwlled English:
    </p>

    <div id="panels">
        <textarea id="ttl-input" rows="10" cols="80"></textarea>
        <input id="translate-btn" type="button" value="Translate">
        <textarea id="cowl-output" readonly rows="10" cols="80"></textarea>
        <input id="copy-btn" type="button" value="Copy to clipboard">
    </div>

<!-- @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix cowl: <http://purl.org/controwlled-english#> .
@prefix ex: <http://example.org/> .

ex:C cowl:template "something"@en .
ex:p cowl:template "knows <>"@en .
ex:q cowl:template "has <> as property"@en .

ex:s a ex:C ; ex:p ex:o ; ex:q ex:o ; ex:p "Robert" .
ex:s rdfs:label "Alice" .
ex:o rdfs:label "Bob" . -->

    <script type="text/javascript">
        function serialize(quad) {
            let s = quad.subject;
            let p = quad.predicate;
            let o = quad.object;

            return s.value + " " + p.value + " " + o.value;
        }

        function Translator(quads) {
            this.labels = {};
            this.templates = {};
            this.statements = [];

            for (quad of quads) {
                let p = quad.predicate.value;

                if (p === "http://www.w3.org/2000/01/rdf-schema#label")
                    // TODO check language tag and prefer English
                    this.labels[quad.subject.value] = quad.object.value;
                else if (p === "http://purl.org/controwlled-english#template")
                    // TODO check template parameters
                    this.templates[quad.subject.value] = quad.object.value;
                else
                    this.statements.push(quad);
            }
        }

        Translator.prototype.instantiate = function(tpl, ...args) {
            let instance = "";

            if (!tpl) return undefined;
            if (args.some(arg => !arg)) return undefined;

            if (args.length === 1) {
                i = args[0];
                instance = i + " is " + tpl;
            } else if (args.length === 2) {
                s = args[0];
                o = args[1];
                instance = s + " " + tpl.replace("<>", o);
            }

            return instance + ".";
        }

        Translator.prototype.verbalize = function(quad) {
            let s = quad.subject.value;
            let p = quad.predicate.value;

            if (p === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                let c = quad.object.value;
                let tpl = this.templates[c];

                return this.instantiate(tpl, this.labels[s]);
            } else {
                let tpl = this.templates[p];
                let qo = quad.object;
                let o = qo.value;

                if (qo.termType === "NamedNode") {
                    o = this.labels[o];
                } else if (qo.termType === "BlankNode") {
                    // TODO construct relative clauses, if possible
                    // TODO otherwise, assign arbitrary name
                    //      use "something that"? Pb. of something/someone
                }

                return this.instantiate(tpl, this.labels[s], o);
            }
        }

        Translator.prototype.getSentences = function() {
            let sentences = [];

            for (let quad of this.statements) {
                let sentence = this.verbalize(quad);
                if (sentence) sentences.push(sentence);
                else console.warn("Ignoring: " + serialize(quad));
            }

            return sentences.join("\n");
        };
    </script>

    <script type="text/javascript">
        const parser = new N3.Parser();

        function parse(ttl) {
            let quads = [];

            return new Promise((resolve, reject) => {
                parser.parse(ttl, (error, quad, prefixes) => {
                    if (error) reject(error);
                    else if (quad) quads.push(quad);
                    else resolve(quads);
                });
            })
        }

        async function translate(ttl) {
            let quads = await parse(ttl);
            let translator = new Translator(quads);
            return translator.getSentences();
        }
    </script>

    <script>
        const ttlInput = document.getElementById('ttl-input');
        const translateButton = document.getElementById('translate-btn');
        const cowlOutput = document.getElementById('cowl-output');
        const copyButton = document.getElementById('copy-btn');

        translateButton.onclick = () => {
            let ttl = ttlInput.value;
            
            translate(ttl)
            .then(txt => cowlOutput.value = txt)
            .catch(error => console.error(error));
        };

        copyButton.onclick = () => {
            navigator.clipboard.writeText(cowlOutput.value);
        };
    </script>
<body>

</html>