<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>SQL et alg√®bre relationnelle</title>

		<link rel="stylesheet" href="../css/slides-reset.css">
		<link rel="stylesheet" href="../css/slides.css">
		<link rel="stylesheet" href="../css/slides-theme.css" id="theme">
		<link rel="stylesheet" href="../css/slides-code.css" id="highlight-theme">

		<style>
			.reveal .slides section section {
				margin-top: 1.5em; /* margin for upper section title */
			}

			.reveal .slides .note {
				padding: 0.5em;
				font-size: 0.5em;
				color: peru;
				background-color: moccasin;
			}

			.reveal .slides .note mark {
				color: brown;
			}
			
			.reveal .slides table {
				font-size: 0.65em;
			}
			
			.reveal .slides table.t {
				font-size: 0.75em;
			}
			
			.reveal .slides table.t th {
				background-color: moccasin;
			}
			
			.reveal .slides table.t td {
				background-color: linen;
			}

            .reveal .slides table.plain {
                border: 0px;
				font-size: 1em;
            }

            .reveal .slides table.plain th {
                text-align: center;
                border: 0px;
            }

            .reveal .slides table.plain td {
                text-align: center;
                border: 0px;
            }

            .reveal .slides table.plain img.thumbnail {
                margin: 20px;
                max-height: 100px;
            }
			
			.reveal .slides .phi {
				text-align: left;
			}
			
			.reveal .slides .sql {
				text-align: left;
			}
			
			.reveal .slides .json {
				text-align: left;
			}
			
			.reveal .slides .cypher {
				text-align: left;
			}
			
			.reveal .slides .gremlin {
				text-align: left;
			}
			
			.reveal .slides .sparql {
				text-align: left;
			}

            .reveal .slides .var {
                color: darkmagenta;
                font-weight: bold;
            }

            .reveal .slides .comment {
                color: lightblue;
            }

            .reveal .slides .param {
                color: lightgray;
            }

            .reveal .slides .string {
                color: peru;
            }

            .reveal .slides .nb {
                color: skyblue;
            }

			.reveal .slides figcaption {
				color: gray;
				font-size: 0.5em;
			}

			.reveal .slides figure img {
				max-height: 8em; /* FIXME should be a percent of total height */
			}

            .reveal .slides caption {
                color: gray;
                font-size: 0.5em;
            }

            .reveal .slides mark {
                background-color: moccasin;
            }
		</style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>SQL et alg√®bre relationnelle</h1>
                    <p><a href="https://www.vcharpenay.link/">Victor Charpenay</a></p>
                </section>
                <section>
                    <h4>D√©roul√© du cours</h4>
                    <section>
                        <ol>
                            <li class="fragment">SQL (rappel)</li>
                            <li class="fragment">
                                Cr√©ation de donn√©es
                                <ol>
                                    <li class="fragment">Relations et sch√©mas</li>
                                    <li class="fragment">Formes normales</li>
                                </ol>
                            </li>
                            <li class="fragment">
                                Requ√™tes sur les donn√©es
                                <ol>
                                    <li class="fragment">Op√©rateurs alg√©briques</li>
                                    <li class="fragment">R√©√©criture de requ√™tes</li>
                                    <li class="fragment">Optimisation par index</li>
                                </ol>
                            </li>
                        </ol>
                    </section>
                </section>
                <section>
                    <h4>SQL (rappel)</h4>
                    <section>
                        <p class="fragment">SQL signifie<br><mark>Structured Query Language</mark></p>
                        <p class="fragment">SQL est un langage <mark>d√©claratif</mark> de manipulation de donn√©es <mark>relationnelles</mark>.</p>
                    </section>
                    <section>
                        <p class="sql">
                            CREATE TABLE <span class="param">table</span>(<span class="param">attribut(s)</span>) ;<br><br>
                            INSERT INTO <span class="param">table</span> VALUES <span class="param">tuple</span> ;
                        </p>
                    </section>
                    <section>
                        <table class="t" style="float: left;">
                            <thead>
                                <tr>
                                    <th>Rang</th>
                                    <th>Nom</th>
                                    <th>Taille</th>
                                    <th>Poids</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>#001</td>
                                    <td>Bulbizarre</td>
                                    <td>0.7m</td>
                                    <td>6.9kg</td>
                                </tr>
                                <tr>
                                    <td>#004</td>
                                    <td>Salam√®che</td>
                                    <td>0.6m</td>
                                    <td>8.5kg</td>
                                </tr>
                                <tr>
                                    <td>#007</td>
                                    <td>Carapuce</td>
                                    <td>0.5m</td>
                                    <td>9.0kg</td>
                                </tr>
                                <tr>
                                    <td>#025</td>
                                    <td>Pikachu</td>
                                    <td>0.4m</td>
                                    <td>6.0kg</td>
                                </tr>
                                <tr>
                                    <td>#052</td>
                                    <td>Miaouss</td>
                                    <td>0.4m</td>
                                    <td>4.2kg</td>
                                </tr>
                            </tbody>
                        </table>

                        <table class="t">
                            <thead>
                                <tr>
                                    <th>Rang</th>
                                    <th>Type</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>#001</td>
                                    <td>Plante</td>
                                </tr>
                                <tr>
                                    <td>#001</td>
                                    <td>Poison</td>
                                </tr>
                                <tr>
                                    <td>#004</td>
                                    <td>Feu</td>
                                </tr>
                                <tr>
                                    <td>#007</td>
                                    <td>Eau</td>
                                </tr>
                                <tr>
                                    <td>#025</td>
                                    <td>√âlectrik</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section>
                        <p class="sql">
                            SELECT <span class="param">attribut(s)</span><br>
                            FROM <span class="param">table(s)</span><br>
                            WHERE <span class="param">condition(s)</span> ;
                        </p>
                    </section>
                    <section>
                        <p>(Q<sub>1</sub>) Quel est le nom des Pok√©mon de type feu ?</p>
                        <p class="fragment sql">
                            SELECT <span class="var">Nom</span><br>
                            FROM <span class="var">Pok√©mon</span> AS <span class="var">P</span>,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">Pok√©monType</span> AS <span class="var">PT</span><br>
                            WHERE <span class="var">P</span>.<span class="var">Rang</span> = <span class="var">PT</span>.<span class="var">Rang</span> AND<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">Type</span> = Feu ;
                        </p>
                    </section>
                    <section data-background-color="moccasin">
                        <p>
                            Quels probl√®mes pratiques peuvent appara√Ætre √† mesure que la taille des tables augmente ?
                        </p>
                    </section>
                    <section>
                        <ul>
                            <li>
                                Ex√©cution trop lente<br>
                                <span style="color: lightgray;">de v√©rification de contraintes</span>
                            </li>
                            <li class="fragment">
                                Ex√©cution trop lente<br>
                                <span style="color: lightgrey;">de requ√™tes</span>
                            </li>
                            <!-- <li class="fragment">Manque d'√©volution de la base de donn√©es</li> -->
                        </ul>
                        <p class="note fragment">
                            √Ä ces probl√®mes pratiques peut √™tre donn√©e une r√©ponse th√©orique.
                        </p>
                    </section>
                </section>
                <section>
                    <h4>Relations et sch√©mas</h4>
                    <section>
                        <p>Le fondement th√©orique d'SQL est le <mark>mod√®le relationnel</mark>.</p>
                        <p class="fragment">Une table (SQL) √©quivaut √† une <mark>relation</mark> dans le mod√®le relationnel.</p>
                    </section>
                    <section>
                        <p>
                            Une relation R est un ensemble de <mark>n-uplet</mark> ou <mark>tuples</mark> {t, t', ‚Ä¶} avec
                        </p>
                        <p class="fragment">
                            t = (t<sub>1</sub>, t<sub>2</sub>, ‚Ä¶, t<sub>n</sub>)
                        </p>
                        <p class="fragment">
                            t' = (t'<sub>1</sub>, t'<sub>2</sub>, ‚Ä¶, t'<sub>n</sub>)
                        </p>
                        <p class="fragment">
                            ‚Ä¶
                        </p>
                    </section>
                    <section>
                        <p class="phi">
                            <span class="var">Pok√©mon</span> = {<br>
                            &nbsp;&nbsp;(#001, Bulbizarre, 0.7, 6.9),<br>
                            &nbsp;&nbsp;(#004, Salam√®che, 0.6, 8.5),<br>
                            &nbsp;&nbsp;(#007, Carapuce, 0.5, 9.0),<br>
                            &nbsp;&nbsp;(#025, Pikachu, 0.4, 6.0),<br>
                            &nbsp;&nbsp;(#052, Miaouss, 0.4, 4.2)<br>
                            }
                        </p>
                    </section>
                    <!-- <section>
                        <p class="phi">
                            Type(#001, Plante)<br>
                            Type(#001, Poison)<br>
                            Type(#004, Feu)<br>
                            Type(#007, Eau)<br>
                            Type(#025, √âlectrik)
                        </p>
                    </section> -->
                    <section>
                        <p>
                            Les valeurs d'un tuple peuvent √™tre index√©es
                        </p>
                        <ul>
                            <li class="fragment">par leur <mark>position</mark></li>
                            <li class="fragment">par un nom ou <mark>attribut</mark></li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            Si l'on suppose que l'ensemble des attributs est <mark>strictement ordonn√©</mark>, les deux repr√©sentations sont √©quivalentes.
                        </p>
                    </section>
                    <section>
                        <p>
                            On peut donc √©crire alternativement
                        </p>
                        <ul>
                            <li class="fragment">t = (t<sub>1</sub>, ‚Ä¶, t<sub>n</sub>)</li>
                            <li class="fragment">t(A<sub>1</sub>) = t<sub>1</sub>, ‚Ä¶, t(A<sub>n</sub>) = t<sub>n</sub></li>
                        </ul>
                        <p class="fragment">
                            et on d√©signe l'ensemble {A<sub>1</sub>, ‚Ä¶, A<sub>n</sub>} comme le <mark>type</mark> de t, not√© type(t).
                        </p>
                        <!-- dans DB Foudations : not√© sort(t) -->
                    </section>
                    <section>
                        <p>
                            Si dans une relation R, tout t ‚àà R a le m√™me type S = {A<sub>1</sub>, ‚Ä¶, A<sub>n</sub>}, on dit alors que R est une instance du <mark>sch√©ma</mark> S.
                        </p>
                    </section>
                    <section>
                        <p>
                            La relation Pok√©mon est une instance du sch√©ma
                        </p>
                        <p class="fragment">
                            S<sub><span class="var">Pok√©mon</span></sub> = {<span class="var">Rang</span>, <span class="var">Nom</span>, <span class="var">Taille</span>, <span class="var">Poids</span>}
                        </p>
                    </section>
                    <section>
                        <p>
                            Une base de donn√©es relationnelles est un <mark>ensemble de relations typ√©es</mark> (chacune instance d'un sch√©ma donn√©).
                        </p>
                    </section>
                </section>
                <section>
                    <h4>Formes normales</h4>
                    <section data-background-color="moccasin">
                        <p>
                            Quelle cas particulier de relation √©tudie-t-on depuis le coll√®ge ?
                        </p>
                    </section>
                    <section>
                        <p>
                            Celui de la <mark>fonction</mark> (math√©matique).
                        </p>
                    </section>
                    <section>
                        <p>
                            La fonction F : x ‚Ü¶ F(x)
                        </p>
                        <ul>
                            <li class="fragment">
                                est une instance du sch√©ma<br>
                                &nbsp;&nbsp;S<sub>F</sub> = {X, Y}</li>
                            <li class="fragment">
                                respecte la contrainte<br>
                                (x, y<sub>1</sub>) ‚àà F, (x, y<sub>2</sub>) ‚àà F ‚áí y<sub>1</sub> = y<sub>2</sub>
                            </li>
                        </ul>
                        <p class="note fragment">
                            On change alors de notation, pour √©crire F(x) = y<sub>1</sub> = y<sub>2</sub>.
                        </p>
                    </section>
                    <section>
                        <p>
                            La contrainte d'unicit√© sur l'application de F est appel√©e ¬´&nbsp;<mark>d√©pendance fonctionnelle</mark>&nbsp;¬ª.
                        </p>
                    </section>
                    <section>
                        <p>
                            Lorsqu'un ensemble d'attributs Y d√©pend fonctionnellement d'un autre ensemble X, on note<br>
                            X ‚Üí Y
                        </p>
                    </section>
                    <section>
                        <p>
                            Un sch√©ma de base de donn√©es est toujours soumis √† au moins une d√©pendance fonctionnelle&nbsp;: celle de <mark>cl√© primaire</mark>.
                        </p>
                    </section>
                    <section>
                        <p>
                            Une cl√© (primaire) est un <mark>ensemble minimal d'attributs</mark> desquels d√©pendent fonctionnellement <mark>tous les attributs</mark> d'un sch√©ma.
                        </p>
                        <p class="note fragment">
                            Cet ensemble d'attributs n'est pas n√©cessairement unique.
                        </p>
                    </section>
                    <section>
                        <p>
                            Le rang d'un Pok√©mon d√©termine son nom, sa taille et son poids.
                        </p>
                        <p class="fragment">
                            <span class="var">Rang</span> ‚Üí {<span class="var">Nom</span>, <span class="var">Taille</span>, <span class="var">Poids</span>}
                        </p>
                        <p class="fragment">
                            Le nom du Pok√©mon aussi.
                        </p>
                        <p class="fragment">
                            <span class="var">Nom</span> ‚Üí {<span class="var">Rang</span>, <span class="var">Taille</span>, <span class="var">Poids</span>}
                        </p>
                    </section>
                    <section>
                        <p>
                            Les d√©pendances fonctionnelles ont certaines propri√©t√©s logiques&nbsp;:
                        </p>
                        <ul>
                            <li class="fragment">
                                X ‚Üí {A<sub>1</sub>, ‚Ä¶, A<sub>n</sub>} ‚áí X ‚Üí A<sub>i &in; [1, n]</sub>
                            </li>
                            <li class="fragment">
                                X ‚Üí Y, Y ‚Üí Z ‚áí X ‚Üí Z
                            </li>
                            <!-- cf autres r√®gles d'inf√©rence (vues aussi comme des axiomes) d'Armstrong -->
                        </ul>
                    </section>
                    <section>
                        <p>
                            Une d√©pendance fonctionnelle X ‚Üí Y est <mark>canonique</mark> si Y est un attribut unique A.
                        </p>
                        <p class="note fragment">
                            La suite du cours suppose une repr√©sentation canonique des d√©pendances.
                        </p>
                    </section>
                    <section>
                        <p>
                            Une base de donn√©es relationnelles est un ensemble de relations typ√©es
                            <span class="fragment"><b>et <mark>satisfaisant</mark> une ou plusieurs <mark>d√©pendances fonctionnelles</mark></b>.</span>
                        </p>
                        <p class="note fragment">
                            Les relations peuvent aussi satisfaire des contraintes dites <mark>d'int√©grit√©</mark>.
                        </p>
                    </section>
                    <section data-background-color="moccasin">
                        <p>Quelle d√©pendance fonctionnelle la base de donn√©es ci-dessous viole-t-elle ?</p>
                    </section>
                    <section>
                        <table class="t">
                            <thead>
                                <tr>
                                    <th>Rang</th>
                                    <th>Nom</th>
                                    <th>Taille</th>
                                    <th>Poids</th>
                                    <th>Type</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>#001</td>
                                    <td>Bulbizarre</td>
                                    <td>0.7m</td>
                                    <td>6.9kg</td>
                                    <td>Plante</td>
                                </tr>
                                <tr>
                                    <td>#001</td>
                                    <td>Bulbizarre</td>
                                    <td>0.7m</td>
                                    <td>6.8kg</td>
                                    <td>Poison</td>
                                </tr>
                                <tr>
                                    <td>#004</td>
                                    <td>Salam√®che</td>
                                    <td>0.6m</td>
                                    <td>8.5kg</td>
                                    <td>Feu</td>
                                </tr>
                                <tr>
                                    <td>#007</td>
                                    <td>Carapuce</td>
                                    <td>0.5m</td>
                                    <td>9.0kg</td>
                                    <td>Eau</td>
                                </tr>
                                <tr>
                                    <td>#025</td>
                                    <td>Pikachu</td>
                                    <td>0.4m</td>
                                    <td>6.0kg</td>
                                    <td>√âlectrik</td>
                                </tr>
                                <tr>
                                    <td>#052</td>
                                    <td>Miaouss</td>
                                    <td>0.4m</td>
                                    <td>4.2kg</td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section>
                        <p>
                            Bulbizarre (#001) a deux valeurs de poids (6.9kg et 6.8kg).
                        </p>
                        <p class="fragment">
                            Les donn√©es violent donc la d√©pendance fonctionnelle<br>
                            <span class="var">Rang</span> ‚Üí <span class="var">Poids</span>
                        </p>
                    </section>
                    <section>
                        <p>
                            V√©rifier la satisfaction de d√©pendances fonctionnelles dans une base de donn√©es est peu co√ªteux
                            <span class="fragment">si son sch√©ma est en <mark>forme normale</mark>.</span>
                        </p>
                        <!-- complexit√© en forme arbitraire : O(n<sub>R</sub>.n<sub>F</sub>) ? -->
                        <p class="note fragment">
                            Une forme normale bas√©e sur les d√©pendances fonctionnelles garantit l'absence √† la fois d'<mark>incoh√©rence</mark> et de <mark>redondance</mark>.
                        </p>
                    </section>
                    <section>
                        <p>
                            Il existe plusieurs formes normales imbriqu√©es l'une dans l'autre&nbsp;:
                        </p>
                        <ol>
                            <li class="fragment">1<sup>√®re</sup> forme normale (1NF)</li>
                            <li class="fragment">2<sup>√®me</sup> forme normale (2NF)</li>
                            <li class="fragment">3<sup>√®me</sup> forme normale (3NF)</li>
                            <li class="fragment">forme normale de Boyce-Codd (BCNF)</li>
                        </ol>
                    </section>
                    <section>
                        <p>
                            Un sch√©ma relationnel est en <mark>1NF</mark> si tous les attributs sont <mark>ind√©composables</mark> (ont des valeurs atomiques).
                        </p>
                    </section>
                    <!-- exemple de violation : "#001 Bulbizarre" ? -->
                    <section>
                        <p>
                            Un attribut A est <mark>non-cl√©</mark> s'il n'appara√Æt dans aucune des cl√©s potentielles du sch√©ma de relation.
                        </p>
                    </section>
                    <section>
                        <p>
                            <span class="var">Taille</span> et <span class="var">Poids</span> sont non-cl√©s.
                        </p>
                    </section>
                    <section>
                        <p>
                            Une d√©pendance fonctionnelle X ‚Üí Y est <mark>√©l√©mentaire</mark> s'il n'existe pas de X' &subset; X tel que X' ‚Üí Y.
                        </p>
                        <p class="fragment">
                            Un attribut A est <mark>pleinement</mark> d√©pendant d'une cl√© K si K ‚Üí A est √©l√©mentaire.
                        </p>
                    </section>
                    <section>
                        <p>
                            <span class="var">Type</span><br>
                            ne d√©pend pleinement que de<br>
                            {<span class="var">Rang</span>, <span class="var">Type</span>}.
                        </p>
                    </section>
                    <section>
                        <p>
                            Un sch√©ma relationnel est en <mark>2NF</mark> s'il est en 1NF et si <mark>tous les attributs non-cl√©s</mark> sont <mark>pleinement d√©pendants de toutes les cl√©s</mark>.
                        </p>
                    </section>
                    <section data-background-color="moccasin">
                        <p>
                            Le sch√©ma ci-dessous n'est pas en 2NF. Pourquoi ?
                        </p>
                    </section>
                    <section>
                        <p class="phi">
                            S<sub><span class="var">PJoinPT</span></sub> = {<br>
                            &nbsp;&nbsp;<span class="var">Rang</span>,
                            <span class="var">Nom</span>,
                            <span class="var">Taille</span>,
                            <span class="var">Poids</span>,
                            <span class="var">Type</span><br>
                            }
                        </p>
                    </section>
                    <section>
                        <p>
                            <span class="var">Taille</span> et <span class="var">Poids</span><br>
                            ne sont pas pleinement d√©pendants de la cl√© potentielle<br>
                            {<span class="var">Rang</span>, <span class="var">Type</span>}.
                        </p>
                    </section>
                    <section>
                        <p>
                            Un attribut A d√©pend <mark>transitivement</mark> d'une cl√© K s'il existe X tel que
                        </p>
                        <ul>
                            <li class="fragment">A &notin; X, X &NotSubsetEqual; K</li>
                            <li class="fragment">X ‚Üõ K</li>
                            <li class="fragment">K ‚Üí X, X ‚Üí A</li>
                        </ul>
                        <p class="fragment">
                            Sinon, A d√©pend <mark>directement</mark> de K.
                        </p>
                        <!-- exemple de rang -> nom -> poids/taille -->
                    </section>
                    <section>
                        <p>
                            Un sch√©ma relationnel est en <mark>3NF</mark> s'il est en 2NF et si <mark>tous les attributs non-cl√©s</mark> sont <mark>directement d√©pendants de toutes les cl√©s</mark>.
                        </p>
                    </section>
                    <section data-background-color="moccasin">
                        <p>
                            Le sch√©ma ci-dessous n'est pas en 3NF. Pourquoi ?
                        </p>
                    </section>
                    <section>
                        <p class="phi">
                            S<sub><span class="var">P2</span></sub> = {<br>
                            &nbsp;&nbsp;<span class="var">Rang</span>,
                            <span class="var">Nom</span>,
                            <span class="var">Taille</span>,
                            <span class="var">Poids</span>,
                            <span class="var">PoidsLourd</span><br>
                            }
                        </p>
                    </section>
                    <section>
                        <p>
                            <span class="var">PoidsLourd</span><br>
                            d√©pend transitivement de<br>
                            <span class="var">Rang</span><br>
                            car
                        </p>
                        <ul>
                            <li class="fragment"><span class="var">Poids</span> ‚Üõ <span class="var">Rang</span></li>
                            <li class="fragment"><span class="var">Rang</span> ‚Üí <span class="var">Poids</span>, <span class="var">Poids</span> ‚Üí <span class="var">PoidsLourd</span></li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            Une d√©pendance fonctionnelle X ‚Üí Y est <mark>triviale</mark> si Y &subseteq; X.
                        </p>
                    </section>
                    <section>
                        <p>
                            Un sch√©ma relationnel est en <mark>BCNF</mark> s'il est en 3NF et si, pour <mark>toute d√©pendance non-triviale</mark> X ‚Üí A, X contient une cl√©.
                        </p>
                    </section>
                </section>
                <section>
                    <h4>Op√©rateurs alg√©briques</h4>
                    <section>
                        <p>
                            Formellement, une alg√®bre (ou structure alg√©brique) est un ensemble de <mark>valeurs</mark> et d'<mark>op√©rations</mark> sur ces valeurs.
                        </p>
                        <p class="fragment">
                            Les alg√®bres classiques sont<br>
                            (‚Ñ§, {+, &times;}) et (‚Ñù, {+, &times;}).
                        </p>
                        <p class="note fragment">
                            L'alg√®bre sur les entiers relatifs est un <mark>anneau</mark>, celle sur les r√©els est un <mark>corps commutatif</mark>.
                        </p>
                        <!-- l'anneau g√©n√©ralise le champ (certaines valeurs n'ont pas d'inverse) -->
                    </section>
                    <section data-background-color="moccasin">
                        <p>
                            Quels sont les principaux op√©rateurs alg√©briques sur l'ensemble des relations (typ√©es) ?
                        </p>
                    </section>
                    <section>
                        <p>Les op√©rateurs relationnels de base sont:</p>
                        <ul>
                            <li class="fragment"><mark>s√©lection</mark> (œÉ)</li>
                            <li class="fragment"><mark>projection</mark> (œÄ)</li>
                            <li class="fragment"><mark>jointure (naturelle)</mark> (‚ãà)</li>
                            <li class="fragment"><mark>renommage</mark> (ùõø)</li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            La <mark>s√©lection œÉ<sub>A=a</sub>(R)</mark> d'une relation R est le sous-ensemble de R
                        </p>
                        <p class="fragment">
                            {t | t ‚àà R, t(A) = a}
                        </p>
                        <p class="note fragment">
                            En SQL, d'autres conditions sont autoris√©es au-del√† de l'√©galit√©.
                        </p>
                    </section>
                    <!-- <section>
                        <p>
                            On √©crit œÉ<sub>f<sub>1</sub>, f<sub>2</sub>, ‚Ä¶, f<sub>k</sub></sub>(R) pour composer des conditions (ou filtres) sur la relation R
                        </p>
                        <p class="fragment">
                            œÉ<sub>f<sub>k</sub></sub>(‚Ä¶œÉ<sub>f<sub>2</sub></sub>(œÉ<sub>f<sub>1</sub></sub>(R))‚Ä¶)
                        </p>
                    </section> -->
                    <section>
                        <p>
                            La <mark>projection œÄ<sub>{A<sub>1</sub>,‚Ä¶,A<sub>k</sub>}</sub>(R)</mark> d'une relation R sur les attributs A<sub>1</sub>, ‚Ä¶, A<sub>k</sub> est l'ensemble
                        </p>
                        <p class="fragment">
                            {(t(A<sub>1</sub>), ‚Ä¶, t(A<sub>k</sub>)) | t ‚àà R}
                        </p>
                        <p class="note fragment">
                            En SQL, œÄ s'exprime avec le mot-cl√© SELECT (√† ne pas confondre avec l'op√©rateur œÉ de s√©lection‚Ä¶)
                        </p>
                    </section>
                    <section>
                        <p>
                            Pour d√©finir la jointure, on introduit la notation <mark>t[S]</mark> pour d√©signer un tuple t' tel que
                        </p>
                        <ul>
                            <li class="fragment">type(t') = S</li>
                            <li class="fragment">t'(A) = t(A) pour tout A ‚àà type(t)</li>
                        </ul>
                        <p class="note fragment">
                            t[S] est le tuple {t'} = œÄ<sub>S</sub>({t})
                        </p>
                    </section>
                    <section>
                        <p>
                            La <mark>jointure naturelle R<sub>1</sub> ‚ãà R<sub>2</sub></mark> de deux relations R<sub>1</sub>, R<sub>2</sub> est l'ensemble
                        </p>
                        <p class="fragment phi">
                            {<br>
                            &nbsp;&nbsp;t |<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;type(t) = S<sub>R<sub>1</sub></sub> &cup; S<sub>R<sub>2</sub></sub>,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;t[S<sub>R<sub>1</sub></sub>] ‚àà R<sub>1</sub>, t[S<sub>R<sub>2</sub></sub>] ‚àà R<sub>2</sub></sub><br>
                            }
                        </p>
                    </section>
                    <section>
                        <p>
                            Le <mark>renommage ùõø<sub>F</sub>(R)</mark> d'une relation R par une fonction de renommage F est la relation
                        </p>
                        <p class="fragment phi">
                            {<br>
                            &nbsp;&nbsp;t' |<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;t'(F(A)) = t(A) pour t ‚àà R, A ‚àà S<sub>R</sub><br>
                        }
                        </p>
                        <!-- fonction de renommage not√©e differemment dans DB Foundations: notation A1.A2... -> B1.B2... -->
                    </section>
                </section>
                <section>
                    <h4>R√©√©criture de requ√™te</h4>
                    <section>
                        <p>Une requ√™te SQL correspond √† une <mark>op√©ration alg√©brique</mark> sur une ou plusieurs relations.</p>
                    </section>
                    <section>
                        <p>(Q<sub>1</sub>) Quel est le nom des Pok√©mon de type feu ?</p>
                        <p class="fragment">
                            œÄ<sub><span class="var">Nom</span></sub>(œÉ<sub><span class="var">Type</span> = Feu</sub>(<span class="var">P</span> ‚ãà <span class="var">PT</span>))
                        </p>
                    </section>
                    <section>
                        <p>
                            On utilise une notation en arbre pour repr√©senter les requ√™tes.
                        </p>
                        <img src="../misc/sql-algebra/q1.png">
                    </section>
                    <section>
                        <p>Une requ√™te peut √™tre optimis√©e gr√¢ce aux <mark>identit√©s alg√©briques</mark> des op√©rateurs.</p>
                    </section>
                    <section>
                        <table>
                            <tr>
                                <td>œÉ<sub>A=a</sub>(œÉ<sub>A'=a'</sub>(Q))</td>
                                <td>‚Üî</td>
                                <td>œÉ<sub>A=a,A'=a'</sub>(Q)</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>œÉ<sub>A=a</sub>(œÄ<sub>S</sub>(Q))</td>
                                <td>‚Üî</td>
                                <td>œÄ<sub>S</sub>(œÉ<sub>A=a</sub>(Q))</td>
                                <td>si A ‚àâ S</td>
                            </tr>
                            <tr>
                                <td>œÉ<sub>A=a</sub>(Q<sub>1</sub> ‚ãà Q<sub>2</sub>)</td>
                                <td>‚Üí</td>
                                <td>œÉ<sub>A=a</sub>(Q<sub>1</sub>) ‚ãà Q<sub>2</sub></td>
                                <td>si A ‚àâ S<sub>Q<sub>2</sub></sub></td>
                            </tr>
                            <tr>
                                <td>œÄ<sub>S</sub>(Q<sub>1</sub> ‚ãà Q<sub>2</sub>)</td>
                                <td>‚Üí</td>
                                <td>œÄ<sub>S</sub>(Q<sub>1</sub>) ‚ãà Q<sub>2</sub></td>
                                <td>si S ‚à© S<sub>Q<sub>2</sub></sub> = ‚àÖ</td>
                            </tr>
                            <tr>
                                <td>Q<sub>1</sub> ‚ãà Q<sub>2</sub></td>
                                <td>‚Üî</td>
                                <td>Q<sub>2</sub> ‚ãà Q<sub>1</sub></td>
                            </tr>
                            <caption>R√®gles de r√©√©criture de requ√™tes (non-exhaustives)</caption>
                        </table>
                        <!-- cf p. 111 de DB Foundations -->
                    </section>
                    <section>
                        <p>
                            Parmi des requ√™tes √©quivalentes, certaines n√©cessitent de parcourir moins de tuples que d'autres.
                        </p>
                    </section>
                    <section data-background-color="moccasin">
                        Parmi les deux arbres de requ√™tes suivants, lequel serait le plus rapide ?
                    </section>
                    <section>
                        <img src="../misc/sql-algebra/q1.png">
                        <img src="../misc/sql-algebra/q2.png">
                    </section>
                    <section>
                        <p>
                            Une heuristique simple pour optimiser des requ√™tes est de <mark>¬´&nbsp;faire descendre&nbsp;¬ª les op√©rations les plus simples</mark> dans l'arbre de requ√™te (s√©lections, puis projections).
                        </p>
                    </section>
                    <section>
                        <table>
                            <tr>
                                <th>Op√©ration</th><th>Complexit√©</th>
                            </tr>
                            <tr>
                                <td>œÉ</td><td>O(n)</td>
                            </tr>
                            <tr>
                                <td>œÄ</td><td>O(n.log<sub>2</sub>(n))</td>
                            </tr>
                            <tr>
                                <td>‚ãà</td><td>O(n<sub>1</sub>.log<sub>2</sub>(n<sub>1</sub>) + n<sub>2</sub>.log<sub>2</sub>(n<sub>2</sub>))</td>
                            </tr>
                            <caption>Complexit√© des op√©rations alg√©briques de base</caption>
                        </table>
                        <!-- cf p. 107 de DB Foundations -->
                        <p class="note fragment">
                            La complexit√© de la jointure est donn√©e pour l'algorithme <mark>sort-merge</mark>. Elle peut √™tre am√©lior√©e avec des index.
                        </p>
                    </section>
                    <section>
                        <p>
                            Parfois, il est pr√©f√©rable d'ex√©cuter une jointure avant une s√©lection.
                        </p>
                    </section>
                    <section>
                        <p>
                            C'est le cas pour la requ√™te suivante&nbsp;:
                        </p>
                        <p class="fragment">(Q<sub>2</sub>) Quels sont les Pok√©mon de type feu pesant moins de 100 kg ?</p>
                    </section>
                    <section>
                        <p>
                            D'autres m√©thodes de r√©√©criture se basent sur des statistiques pr√©-calcul√©es sur la base de donn√©es.
                        </p>
                    </section>
                    <section>
                        <p>
                            Par exemple, la s√©lectivit√© de la condition <span class="var">PT</span>.<span class="var">Type</span> = Feu est bien sup√©rieure √† celle de <span class="var">P</span>.<span class="var">Poids</span> &lt; 100kg.
                        </p>
                        <img style="width: 30%;" src="../misc/sql-algebra/pokemon-type.png">
                        <img style="width: 30%;" src="../misc/sql-algebra/pokemon-weight.png">
                    </section>
                    <section>
                        <p>
                            Les moteurs de requ√™tes ont g√©n√©ralement la strat√©gie suivante&nbsp;:
                        </p>
                        <ol>
                            <li class="fragment">g√©n√©rer un grand nombre de requ√™tes √©quivalentes</li>
                            <li class="fragment">estimer leur co√ªt sur la base d'heuristiques configurables</li>
                            <li class="fragment">√©valuer la requ√™te au co√ªt le plus faible</li>
                        </ol>
                    </section>
                    <section>
                        <p>
                            Le plan d'√©valuation final d'une requ√™te peut aussi <mark>fusionner</mark> certaines op√©rations pour minimiser les acc√®s m√©moires.
                        </p>
                    </section>
                    <section>
                        <p>
                            Par exemple, lors de la <mark>mat√©rialisation d'une jointure</mark>, les <mark>s√©lections et projections en amont</mark> (dans l'arbre de requ√™te) peuvent √™tre ex√©cut√©es en m√™me temps.
                        </p>
                    </section>
                </section>
                <section>
                    <h4>Optimisation par index</h4>
                    <section>
                        <p>Une requ√™te peut aussi √™tre optimis√©e gr√¢ce √† des <mark>index</mark> sur les relations.</p>
                    </section>
                    <section>
                        <table>
                            <thead>
                                <tr>
                                    <th>Type d'index</th>
                                    <th>Complexit√©</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>table de hachage</td>
                                    <td>recherche d'√©l√©ment en O(1)</td>
                                </tr>
                                <tr>
                                    <td>B-arbre</td>
                                    <td>recherche d'√©l√©ment en O(log<sub>2</sub>(n))</td>
                                </tr>
                            </tbody>
                            <caption>Structures d'index et complexit√© pour la recherche d'√©l√©ment</caption>
                        </table>
                    </section>
                    <section>
                        <p>
                            Par d√©faut, les gestionnaires de base de donn√©es cr√©ent un <mark>index</mark> par table de hachage <mark>pour chaque cl√© primaire</mark>.
                        </p>
                    </section>
                    <section data-background-color="moccasin">
                        <p>
                            Pourquoi est-ce important ?
                        </p>
                    </section>
                    <section>
                        <p>
                            La jointure par cl√© primaire passe en <mark>O(n<sub>2</sub>)</mark> avec un index.
                        </p>
                    </section>
                </section>
                <section>
                    <h4>Pour aller plus loin</h4>
                    <section>
                        Serge Abiteboul, Richard Hull, Victor Vianu (1995), <a href="http://webdam.inria.fr/Alice/">Foundations of Databases</a>, Addison-Wesley.
                    </section>
                </section>
            </div>
        </div>

		<script src="../js/slides.js"></script>
		<script src="../js/slides-code.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				plugins: [ RevealHighlight ]
			});
		</script>
    </body>
</html>